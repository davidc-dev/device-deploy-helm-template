nameOverride: ""
fullnameOverride: ""

image:
  repository: ghcr.io/example/device-app
  tag: "1.0.0"
  pullPolicy: IfNotPresent

replicaCount: 1

service:
  type: ClusterIP
  port: 8080
  targetPort: 8080
  annotations: {}

route:
  enabled: true
  host: ""        # leave empty for autogenerated; or set apps.<cluster-domain>
  tls:
    termination: edge
    insecureEdgeTerminationPolicy: Redirect
  annotations: {}

resources:
  limits:
    cpu: "500m"
    memory: "512Mi"
  requests:
    cpu: "100m"
    memory: "256Mi"

podSecurityContext: {}
securityContext:
  runAsNonRoot: true
  allowPrivilegeEscalation: false

serviceAccount:
  create: true
  name: ""
  annotations: {}  # place workload identity annotations here if needed

# Non-secret config that used to live in device.yaml (public-ish params only)
config:
  enabled: true
  device_id: "example-device-id"
  device_name: "example-device-name"
  extraEnv: []  # list of { name: ..., value: ... }

# Azure Key Vault via Secrets Store CSI
akv:
  enabled: true
  name: "my-key-vault-name"   # Key Vault name
  tenantId: "<aad-tenant-guid>"
  # Choose one auth mode (prefer workload identity):
  auth:
    mode: "workloadIdentity"  # workloadIdentity | servicePrincipal
    workloadIdentity:
      # For Azure Workload Identity: add SA annotations via serviceAccount.annotations
      # Example: "azure.workload.identity/client-id": "<user-assigned-managed-identity-client-id>"
      # or "aadpodidbinding": "<pod-identity-binding>"
      userAssignedIdentityClientId: ""  # optional, if your cluster uses this pattern
    servicePrincipal:
      clientId: ""
      clientSecretValue: ""   # optional: set via --set-file for non-cluster templating
      # clientSecretSecretRef -> a pre-existing K8s Secret with the SP secret
      clientSecretSecretRef:
        name: ""
        key: "clientSecret"
  # The secrets to pull from Key Vault (certs, secrets, keys)
  objects:
    - objectName: "api-token"
      objectType: "secret"
      objectVersion: ""        # optional (latest if empty)
      # objectAlias: "API_TOKEN" # optional alias filename
    - objectName: "db-password"
      objectType: "secret"
      objectVersion: ""
  # Sync to native K8s Secret for envFrom etc.
  syncK8sSecret:
    enabled: false
    name: "device-secrets"
    type: Opaque
    # map the mounted files to K8s Secret keys (if alias not provided, file name = objectName)
    mappings:
      - key: API_TOKEN
        objectName: "api-token"
      - key: DB_PASSWORD
        objectName: "db-password"

# Storage
storage:
  useNfs: true
  mountPath: "/data"
  subPath: ""           # optional subPath within the PVC
  # PVC
  pvc:
    create: true
    name: "device-data"
    storageClassName: ""   # leave empty to use default; set for ODF/AzureDisk/File
    accessModes: ["ReadWriteMany"]
    size: "5Gi"

  # Optionally create a static NFS PV (cluster-scoped; requires cluster-admin to install)
  createPV: false
  pv:
    name: "device-nfs-pv"
    capacity: "100Gi"
    accessModes: ["ReadWriteMany"]
    nfs:
      server: "10.0.0.10"
      path: "/exports/device-app"
    persistentVolumeReclaimPolicy: Retain
    mountOptions: ["vers=4.1","rsize=1048576","wsize=1048576","hard","timeo=600","retrans=2"]

# Probes
livenessProbe:
  httpGet:
    path: /healthz
    port: 8080
  initialDelaySeconds: 10
  timeoutSeconds: 1

readinessProbe:
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 5
  timeoutSeconds: 1

nodeSelector: {}
tolerations: []
affinity: {}
